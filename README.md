# File-based workflows for the DoIt automation tool
The goal of this project is to create a library of file collection and mapping classes that provide `action`, `file_dep` and `target` parameters to [DoIt][1] tasks. The mappers allow specifying tasks that rely on globs and file name mapping rather than having to explicity name every file dependency and every target. This is for text and data processing tasks that happen in several stages where data is converted, enriched, filtered and merged.

The classes are inspired by concepts in the popular [Ant][2] and [Ruffus][3] build tools.

## FileMapper usage
A typical DoIt Python task calls a function with a list of target files:

```python
def task_convert_to_json():
    def process_files(targets):
        for t in target:
            # read target, map to json, write to individual json file
    return {
        "actions": [process_files],
        "targets": ["file1.csv", "file2.csv"]
    }
```

A file mapper can produce a "source" file for every target file. Consider the easiest case where you want to create a new, processed file for every source file:

```python
from doitfilemappers import GlobMapper

def task_convert_to_json():
    def process_file(in_file, out_file):
        with in_file.open("r") as _in, out_file.open("w") as _out:
            # read from _in, process data, write to _out
    mapper = GlobMapper("src/*.csv", process_file, pattern="dst/*.json")
    return mapper.get_task()
```

You must always provide a callback to the mapper that receives one source file and one target file as [`pathlib.Path`][5] instances. This callback will be called for every source/target pair of the mapper.

The `get_task` method of the mapper will return the task data with an action (generated by the mapper using the callback), targets and file dependencies. If you want to have additional task parameters like `uptodate`, `basename`, `title`, etc. you can provide them as a dict parameter to `get_task`:

```python
mapper.get_task({"basename":"foo"})
```

The action generated by the mapper will __ignore__ the targets parameter provided by DoIt and use the internal mapping instead.

### Mapper constructor parameters
The following parameters are common for all mappers
- `src`: Designate which source files should be selected. Always a glob path to be used by [`Pathlib`][4]. Defaults to all files (`*`).
- `callback`: A callable with `input_file`, `output_file` parameters.
- `dir`: Operating directory. The glob expression in `src` will be evaluated in the context of this path. If `dir` is absolute, the generated targets will be absolute too. Otherwise they will be relative. Defaults to `.` (current directory).
- `file_dep`: If true, `get_task` creates `file_dep` with the source files from the mapper. For most mappers it is true.
- `follow_symlinks`: If set to false, only files are mapped. Defaults to true.

### Using mappers with commandline tasks

TODO

### Decorators for your callback function
If you'd rather work with open files instead of opening and closing them yourself, you can use the `@open_files` decorator:

```python
@open_files
def process_file(in_file, out_file):
    data = in_file.read()
    # process data
    out_file.write(data)
```

Normally the input file is opened in read mode, the output file is opened in write mode. You can change the modes with the `in_mode` and `out_mode` parameters for `@open_file`.

If you want to keep track of the number of files that were processed, use the `@track_file_count` decorator and a `file_count` parameter in your callback:

```python
@track_file_count
def process_file(in_file, out_file, file_count=0):
    if file_count > 99:
        raise RuntimeError("Too many files, I quit!")
```

## Types of Mappers
### IdentityMapper
This simple mapper returns all files found by the `src` glob as targets and has no `file_dep` (because that would create a cyclic dependency). 

The IdentityMapper is useful for processing files in-place or processing files without changing them.

### GlobMapper
The GlobMapper uses a single asterisk to define a simple replacement pattern.

```python
def task_json2html():
    def process_file(in_file, out_file):
        # do stuff here
    mapper = GlobMapper("*.json", process_file, "*.html")
    return mapper.get_task()
```

If your `src` parameter contains a single file name, a directory glob like `**/*.json`, multiple asterisks like `*.txt*` or complex globs like `ba[rz].txt` you **must** provide a replacement pattern that contains a single asterisk. 

```python
mapper = GlobMapper("**/*.json", process_file, "*.html", "*.json")
```

If a single asterisk is not sufficient for your replacement needs, use `RegexMapper` instead.

### RegexMapper

The RegexMapper uses a regular expression to allow for more complex filename transformations.

```python
import shutils

def task_move_files():
    """ Rename files named "Foo_Bar.txt" to "Bar-Foo.txt" """
    mapper = RegexMapper("*.txt", shutils.move, r"^(\w+)_(\w+)", r"\2-\1")
    return mapper.get_task()
```

RegexMapper has the parameter `ignore_nonmatching`. If set to `False`, the map will contain files that do not match the search expression. 

```python
def task_process_text():
    """ 
    Process all files and output files named "Foo_Bar.txt" as "Bar-Foo.txt".
    All other files will keep their name.
    """
    def process_text(_in, _out):
        if _in.suffix() == ".txt":
            # process text file
        elif _in.suffix() == ".csv":
            # process CSV file

    mapper = RegexMapper("*", process_text, 
        search=r"^(\w+)_(\w+)(\.txt)", 
        replace=r"\2-\1\3", 
        ignore_nonmatching=True, 
        file_dep=False
    )
    return mapper.get_task()
```

### MergeMapper

In merge mapper you have to open the output file for appending (mode `a`) instead of opening it while truncating it (mode `w`). If the target file exists, the content from all source files will be appended to it - not a desired bahvior in most cases. To avoid a separate task where you delete the target file before opening using the task with the MergeMapper you can use the `@open_files_for_merge` decorator which keeps track of the files, opens the first one with mode `w` and all following files with mode `a`.

### CompositeMapper
This mapper returns the combined map of several mappers.

```python
def task_convert_images():
    def convert_img(image_in, image_out):
        # do some processing here
    sub_mappers = [
        GlobMapper("*.jpg", replace="*_thumb.jpg"),
        GlobMapper("*.jpeg", replace="*_thumb.jpg")
    ]
    mapper = CompositeMapper(sub_mappers, convert_img)
    return mapper.get_task()
```

### ChainedMapper


## TODO
- Support arrays of glob strings in the `src` parameter.
- Add uptodate function to mappers that returns the result of checking timstamps of each source and taregt file in the map.

[1]: http://pydoit.org/ 
[2]: http://ant.apache.org/
[3]: http://www.ruffus.org.uk/
[4]: https://pathlib.readthedocs.org/
[5]: https://docs.python.org/3/library/pathlib.html#concrete-paths